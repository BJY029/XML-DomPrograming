import java.awt.EventQueue;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import javax.swing.SwingUtilities;
import java.awt.EventQueue;
import java.awt.Font;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.JComboBox;


import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import javax.swing.JTextField;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.swing.JTextPane;

public class FindFrame {

	private JFrame frame;
	private JTextField NameField;
	private JComboBox resultComboBox;
	private List<Node> foundNodes = new ArrayList<>();
	private JTextField DetailTextField;
	private JButton DetailsBtn;

	public FindFrame() {
		initialize();
	}
	
	public void setVisible(boolean b) {
		frame.setVisible(b);
	}

	public void returnToMain() {
		SwingUtilities.invokeLater(() -> {
			JFrame toClose = this.frame; // 닫을 대상 보관
			MainFrame main = new MainFrame();
			main.setVisible(true); // 새 메인 띄우기
			if (toClose != null)
				toClose.dispose(); // 반드시 명시적으로 닫기
		});
	}
	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		frame = new JFrame();
		frame.setBounds(100, 100, 1120, 750);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(null);
		
		if(!FileData.isLoaded())
		{
			JOptionPane.showMessageDialog(null, "No files have been loaded, please load the files first.", "ERROR", JOptionPane.ERROR_MESSAGE);
			returnToMain();
			return;
		}
		
		JLabel TypeLabel = new JLabel("Type");
		TypeLabel.setFont(new Font("굴림", Font.PLAIN, 18));
		TypeLabel.setHorizontalAlignment(SwingConstants.CENTER);
		TypeLabel.setBounds(159, 10, 89, 33);
		frame.getContentPane().add(TypeLabel);
		frame.setLocationRelativeTo(null);
		
		JLabel NameLabel = new JLabel("Name");
		NameLabel.setHorizontalAlignment(SwingConstants.CENTER);
		NameLabel.setFont(new Font("굴림", Font.PLAIN, 18));
		NameLabel.setBounds(482, 10, 89, 33);
		frame.getContentPane().add(NameLabel);
		
		String[] TypeList = {"ELEMENT", "ATTRIBUTE", "TEXT", "COMMENT"};
		JComboBox comboBox = new JComboBox(TypeList);
		comboBox.setBounds(254, 15, 188, 23);
		frame.getContentPane().add(comboBox);
		
		NameField = new JTextField();
		NameField.setFont(new Font("Gulim", Font.PLAIN, 12));
		NameField.setBounds(573, 17, 223, 21);
		frame.getContentPane().add(NameField);
		NameField.setColumns(10);
		
		JButton SearchBtn = new JButton("Search");
		SearchBtn.setBounds(819, 16, 97, 23);
		SearchBtn.addActionListener(e -> Find(FileData.document.getDocumentElement(), comboBox.getSelectedItem().toString(), NameField.getText()));
		frame.getContentPane().add(SearchBtn);
		
		resultComboBox = new JComboBox();
		resultComboBox.setBounds(409, 53, 287, 23);
		frame.getContentPane().add(resultComboBox);
		
		DetailsBtn = new JButton("Details");
		DetailsBtn.setEnabled(false);
		DetailsBtn.addActionListener(e -> showDetails());
		DetailsBtn.setFont(new Font("굴림", Font.PLAIN, 14));
		DetailsBtn.setBounds(500, 86, 97, 23);
		frame.getContentPane().add(DetailsBtn);
		
		DetailTextField = new JTextField();
		DetailTextField.setFont(new Font("굴림", Font.PLAIN, 24));
		DetailTextField.setHorizontalAlignment(SwingConstants.CENTER);
		DetailTextField.setEditable(false);
		DetailTextField.setBounds(12, 123, 1080, 546);
		frame.getContentPane().add(DetailTextField);
		DetailTextField.setColumns(10);
		
	}
	
	private void Find(Node node, String Type,  String Name)
	{
		foundNodes.clear();
		
		switch(Type) {
		case "ELEMENT":
			FindElement(node, Name);
			break;
		case "ATTRIBUTE":
			FindAttribute(node, Name);
			break;
		case "TEXT":
			FindText(node, Name);
			break;
		case "COMMENT":
			FindComment(node, Name);
			break;
		}
		
		UpdateResultComboBox();
	}
	
	private void UpdateResultComboBox()
	{
		resultComboBox.removeAllItems();
		
		if(foundNodes == null || foundNodes.isEmpty()) {
			resultComboBox.addItem("No Items");
			resultComboBox.setSelectedIndex(0);
			DetailsBtn.setEnabled(false);
			return;
		}
		int idx = 0;
		for(Node node : foundNodes) {
			String name = node.getNodeName();
			resultComboBox.addItem(name + idx);
			idx++;
		}
		resultComboBox.setSelectedIndex(0);
		DetailsBtn.setEnabled(true);
	}
	
	private void FindElement(Node node, String Name)
	{
		if(node == null) return;
		
		NodeList children = node.getChildNodes();
		for(int i = 0; i < children.getLength(); i++) {
			Node child = children.item(i);
			
			if(child.getNodeName().equals(Name)) {
				foundNodes.add(child);
			}
			
			FindElement(child, Name);
		}
	}
	
	private void FindAttribute(Node node, String Name) {
		
	}

	private void FindText(Node node, String Name) {
		
	}
	
	private void FindComment(Node node, String Name) {
		
	}
	
	private void showDetails()
	{
		int nodeIdx = resultComboBox.getSelectedIndex();
		Node node = foundNodes.get(nodeIdx);
		
		switch(getNodeTypeName(node))
		{
		case "ELEMENT":
			showElementDetails(node);
			break;
		case "ATTRIBUTE":
			showAttributeDetails(node);
			break;
		case "COMMENT":
			showCommentDetails(node);
			break;
		case "TEXT":
			showTextDetails(node);
			break;
		}
		
	}
	
	private void showElementDetails(Node node)
	{
		
		
		String nodeType = getNodeTypeName(node);
		String nodeName = node.getNodeName();
		String nodeValue = node.getNodeValue();
		String parentNodeName = node.getParentNode().getNodeName();
		String nodeDepth = getDepth(node) + "";
		String siblingIdx = getSiblingIndex(node) + "";
		
		NodeList children = node.getChildNodes();
		String childrendCnt = children.getLength() + "";
		ArrayList<String> childrens = new ArrayList<String>();
		for(int i = 0; i < children.getLength(); i++) {
			childrens.add(children.item(i).getNodeName());
		}
	}
	
	private void showAttributeDetails(Node node) {
		
	}
	
	private void showCommentDetails(Node node) {
		
	}
	
	private void showTextDetails(Node node) {
		
	}
	
	private String getNodeTypeName(Node node)
	{
		int type = node.getNodeType();
		switch(type)
		{
		case Node.DOCUMENT_NODE:
			return "DOCUMENT";
		case Node.ENTITY_NODE:
			return "ENTITY";
		case Node.ELEMENT_NODE:
			return "ELEMENT";
		case Node.ENTITY_REFERENCE_NODE:
			return "ENTITY_REFERENCE";
		case Node.CDATA_SECTION_NODE:
			return "CDATA_SECTION";
		case Node.COMMENT_NODE:
			return "COMMENT";
		case Node.TEXT_NODE:
			return "TEXT";
		case Node.ATTRIBUTE_NODE:
			return "ATTRIBUTE";
		}
		return "EXCEPTION";
	}
	
	
	
	private int getDepth(Node node)
	{
		int idx = 0;
		while((node = node.getParentNode()) != null) idx++;
		return idx;
	}
	
	private int getSiblingIndex(Node node)
	{
		int idx = 1;
		
		while((node = node.getPreviousSibling()) != null)
		{
			if(node.getNodeType() != Node.TEXT_NODE && node.getNodeType() != Node.COMMENT_NODE) idx++;
		}
		
		return idx;
	}
}
